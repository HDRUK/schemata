# generated by datamodel-codegen:
#   filename:  schema_old.json
#   timestamp: 2023-09-25T14:00:01+00:00

from __future__ import annotations

from datetime import date, datetime
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, EmailStr, Extra, Field, constr


class Required(BaseModel):
    gatewayId: str = Field(
        ...,
        description='Need a field in Mauro that captures the datasetID to link to gateway database - or can we just use the one created in Mauro?',
        title='Gatewayid',
    )
    gatewayPid: str = Field(
        ...,
        description='Need a field in Mauro that captures the dataset pid to link to gateway database',
        title='Gatewaypid',
    )
    issued: datetime = Field(
        ...,
        description="Aren't issued and modified always the same because of versioning? Is that fine to duplicate because datasets in dcat might look different?",
        title='Issued',
    )
    modified: datetime = Field(
        ...,
        description="Aren't issued and modified always the same because of versioning? Is that fine to duplicate because datasets in dcat might look different?",
        title='Modified',
    )
    revisions: List[Dict[str, Any]] = Field(..., title='Revisions')


class Publisher(BaseModel):
    publisherName: Optional[str] = Field(None, title='Publishername')
    publisherGatewayId: Optional[str] = Field(None, title='Publishergatewayid')

 
class Summary(BaseModel):
    title: Optional[constr(min_length=2, max_length=255)] = Field(None, title='Title')
    shortTitle: Optional[constr(min_length=2, max_length=100)] = Field(
        None, title='Shorttitle'
    )
    doiName: Optional[constr(regex=r'^10.\d{4,9}/[-._;()/:a-zA-Z0-9]+$')] = Field(
        None, title='Doiname'
    )
    abstract: Optional[constr(min_length=2, max_length=5000)] = Field(
        None, title='Abstract'
    )
    keywords: Optional[str] = Field(None, title='Keywords')
    controlledKeywords: Optional[str] = Field(None, title='Controlledkeywords')
    contactPoint: Optional[EmailStr] = Field(None, title='Contactpoint')
    datasetType: Optional[str] = Field(None, title='Dataset type')
    description: Optional[str] = Field(None, title='Description')
    publisher: Optional[Publisher] = Field(
        default_factory=lambda: Publisher.parse_obj(
            {'publisherName': None, 'publisherGatewayId': None}
        ),
        title='Publisher',
    )


class FollowUp(BaseModel):
    __root__: str = Field(..., title='FollowUp')


class TypicalAgeRange(BaseModel):
    __root__: str = Field(..., title='TypicalAgeRange')


class Coverage(BaseModel):
    spatial: Optional[str] = Field(None, title='Spatial')
    physicalSampleAvailability: Optional[str] = Field(
        [], title='Physicalsampleavailability'
    )
    pathway: Optional[str] = Field(None, title='Pathway')
    followup: Optional[FollowUp] = Field(None, title='Followup')
    typicalAgeRange: Optional[TypicalAgeRange] = Field(None, title='Typicalagerange')


class Origin(BaseModel):
    purpose: Optional[str] = Field(None, title='Purpose')
    source: Optional[str] = Field(None, title='Source')


class Temporal(BaseModel):
    endDate: Optional[date] = Field('2023-07-03', title='Enddate')
    startDate: Optional[date] = Field('2023-07-03', title='Startdate')
    timeLag: Optional[str] = Field(None, title='Time Lag')
    accrualPeriodicity: Optional[str] = Field(None, title='Accrual Periodicity')


class Provenance(BaseModel):
    origin: Optional[Origin] = Field(
        default_factory=lambda: Origin.parse_obj({'purpose': None, 'source': None}),
        title='Origin',
    )
    temporal: Optional[Temporal] = Field(
        default_factory=lambda: Temporal.parse_obj(
            {
                'endDate': '2023-07-03',
                'startDate': '2023-07-03',
                'timeLag': None,
                'accrualPeriodicity': None,
            }
        ),
        title='Temporal',
    )


class DeliveryLeadTime(BaseModel):
    __root__: str = Field(..., title='DeliveryLeadTime')


class Access(BaseModel):
    deliveryLeadTime: Optional[DeliveryLeadTime] = Field(None, title='Deliveryleadtime')
    jurisdiction: Optional[str] = Field(None, title='Jurisdiction')
    dataController: Optional[str] = Field(None, title='Datacontroller')
    dataProcessor: Optional[str] = Field(None, title='Dataprocessor')
    accessRights: Optional[str] = Field(None, title='Accessrights')
    accessService: Optional[str] = Field(None, title='Accessservice')
    accessRequestCost: Optional[str] = Field(None, title='Accessrequestcost')


class Usage(BaseModel):
    dataUseLimitation: Optional[str] = Field(None, title='Datauselimitation')
    dataUseRequirement: Optional[str] = Field(None, title='Datauserequirement')
    resourceCreator: Optional[str] = Field(None, title='Resourcecreator')


class FormatAndStandards(BaseModel):
    vocabularyEncodingSchemes: Optional[str] = Field(
        None, title='Vocabularyencodingscheme'
    )
    conformsTo: Optional[str] = Field(None, title='Conformsto')
    languages: Optional[str] = Field(None, title='Languages')
    formats: Optional[str] = Field(None, title='Formats')


class Accessibility(BaseModel):
    access: Optional[Access] = Field(
        default_factory=lambda: Access.parse_obj(
            {
                'deliveryLeadTime': None,
                'jurisdiction': None,
                'dataController': None,
                'dataProcessor': None,
                'accessRights': None,
                'accessService': None,
                'accessRequestCost': None,
            }
        ),
        title='Access',
    )
    usage: Optional[Usage] = Field(
        default_factory=lambda: Usage.parse_obj(
            {
                'dataUseLimitation': None,
                'dataUseRequirement': None,
                'resourceCreator': None,
            }
        ),
        title='Usage',
    )
    formatAndStandards: Optional[FormatAndStandards] = Field(
        default_factory=lambda: FormatAndStandards.parse_obj(
            {
                'vocabularyEncodingSchemes': None,
                'conformsTo': None,
                'languages': None,
                'formats': None,
            }
        ),
        title='Formatandstandards',
    )


class Observations1(BaseModel):
    observedNode: Optional[str] = Field(None, title='')
    measuredValue: Optional[str] = Field(None, title='')
    observationDate: Optional[str] = Field(None, title='')
    measuredProperty: Optional[str] = Field(None, title='')


class Observations(BaseModel):
    __root__: Union[List, Observations1] = Field(..., title='Observations')


class DatasetLinkage(BaseModel):
    isDerivedFrom: Optional[str] = Field(None, title='Isderivedfrom')
    isPartOf: Optional[str] = Field(None, title='Ispartof')
    isMemberOf: Optional[str] = Field(None, title='Ismemberof')


class Linkage(BaseModel):
    isReferenceIn: Optional[str] = Field(None, title='Isreferencein')
    IsGeneratedUsing: Optional[str] = Field(None, title='Generated by using tool?')
    dataUses: Optional[str] = Field(None, title='What data uses this?')
    associatedMedia: Optional[str] = Field(None, title='Associatedmedia')
    datasetLinkage: Optional[DatasetLinkage] = Field(
        default_factory=lambda: DatasetLinkage.parse_obj(
            {'isDerivedFrom': None, 'isPartOf': None, 'isMemberOf': None}
        ),
        title='Datasetlinkage',
    )


class DataValue(BaseModel):
    class Config:
        extra = Extra.forbid

    name: str = Field(
        ..., description='What is the value e.g. Male/Female', title='Value Name'
    )
    frequency: float = Field(
        ..., description='What is the frequency of the value', title='Value Frequency'
    )


class DataElement(BaseModel):
    class Config:
        extra = Extra.forbid

    name: Optional[str] = Field(
        ..., description='The name of a column in a table.', title='Column Name'
    )
    dataType: str = Field(
        ..., description='The data type of values in the column', title='Data Type'
    )
    description: Optional[constr(min_length=1, max_length=20000)] = Field(
        None,
        description='A description of a column in a table.',
        title='Column Description',
    )
    sensitive: bool = Field(
        ...,
        description='A True or False value, indicating if the field is sensitive or not',
        title='Sensitive',
    )
    elements: Optional[List[DataValue]] = Field(
        None, description='Temporary for frequency data', title='Data Values'
    )


class DataClass(BaseModel):
    class Config:
        extra = Extra.forbid

    name: Optional[str] = Field(
        ..., description='The name of a table in a dataset.', title='Table Name'
    )
    description: Optional[constr(min_length=1, max_length=20000)] = Field(
        None,
        description='A description of a table in a dataset.',
        title='Table Description',
    )
    elements: List[DataElement] = Field(
        ...,
        description='A list of data elements contained within a table in a dataset.',
        title='Data Elements',
    )


class GDMv1(BaseModel):
    class Config:
        extra = Extra.forbid

    required: Required
    summary: Optional[Summary] = Field(
        default_factory=lambda: Summary.parse_obj(
            {
                'title': None,
                'shortTitle': None,
                'doiName': None,
                'abstract': None,
                'keywords': None,
                'controlledKeywords': None,
                'contactPoint': None,
                'datasetType': None,
                'description': None,
                'publisher': {'publisherName': None, 'publisherGatewayId': None},
            }
        ),
        title='Summary',
    )
    coverage: Optional[Coverage] = Field(
        default_factory=lambda: Coverage.parse_obj(
            {
                'spatial': None,
                'physicalSampleAvailability': [],
                'pathway': None,
                'followup': None,
                'typicalAgeRange': None,
            }
        ),
        title='Coverage',
    )
    provenance: Optional[Provenance] = Field(
        default_factory=lambda: Provenance.parse_obj(
            {
                'origin': {'purpose': None, 'source': None},
                'temporal': {'endDate': '2023-07-03', 'startDate': '2023-07-03'},
            }
        ),
        title='Provenance',
    )
    accessibility: Optional[Accessibility] = Field(
        default_factory=lambda: Accessibility.parse_obj(
            {
                'access': {
                    'deliveryLeadTime': None,
                    'jurisdiction': None,
                    'dataController': None,
                    'dataProcessor': None,
                    'accessRights': None,
                    'accessService': None,
                    'accessRequestCost': None,
                },
                'usage': {
                    'dataUseLimitation': None,
                    'dataUseRequirement': None,
                    'resourceCreator': None,
                },
                'formatAndStandards': {
                    'vocabularyEncodingSchemes': None,
                    'conformsTo': None,
                    'languages': None,
                    'formats': None,
                },
            }
        ),
        title='Accessibility',
    )
    observations: Optional[Observations] = Field(
        default_factory=lambda: Observations.parse_obj({'observationsList': []}),
        title='Observations',
    )
    structuralMetadata: Optional[List[DataClass]] = Field(
        None,
        description='Descriptions of all tables and data elements that can be included in the dataset',
        title='Structural Metadata',
    )
    linkage: Optional[Linkage] = Field(
        default_factory=lambda: Linkage.parse_obj(
            {
                'isReferenceIn': None,
                'IsGeneratedUsing': None,
                'dataUses': None,
                'associatedMedia': None,
                'datasetLinkage': {
                    'isDerivedFrom': None,
                    'isPartOf': None,
                    'isMemberOf': None,
                },
            }
        ),
        title='Linkage',
    )
